[Вернуться][main]

# Понимание хэш-функции

Хэш-функция выполняет хэширование, превращая любые данные в последовательность байтов фиксированного размера, называемую
хэш-значением или хэш-кодом. Это число, которое может служить цифровым отпечатком или дайджестом, обычно гораздо
меньшим, чем исходные данные, что позволяет проверить их целостность. Если вы когда-нибудь получали из Интернета большой
файл, например, образ диска с дистрибутивом `Linux`, то, возможно, заметили на странице загрузки контрольную сумму `MD5`
или
`SHA-2`.

Помимо проверки целостности данных и решения проблемы словаря, хэш-функции помогают и в других областях, включая
безопасность и криптографию. Например, для снижения риска утечки данных в базах данных обычно хранятся хэшированные
пароли. Цифровые подписи используют хэширование для создания дайджеста сообщения перед шифрованием.
Блокчейн-транзакции - еще один яркий пример использования хэш-функции в криптографических целях.

> Примечание:
>
> Криптографическая хэш-функция - это особый тип хэш-функции, который должен удовлетворять нескольким
> дополнительным требованиям. В текущем семинаре мы познакомимся только с самой простой формой хэш-функции,
> используемой в структуре данных хэш-таблицы.

Хотя существует множество алгоритмов хэширования, все они обладают несколькими общими свойствами.
Корректная реализация хорошей хэш-функции - сложная задача, которая может потребовать понимания сложной
математики, связанной с простыми числами. К счастью, обычно нет необходимости реализовывать такой алгоритм вручную.

Python поставляется со встроенным модулем [hashlib][hashlib], который предоставляет множество известных
криптографических хэш-функций, а также менее безопасные алгоритмы контрольных сумм. В языке также имеется глобальная
функция `hash()`, используемая в основном для быстрого поиска элементов в словарях и наборах.
Чтобы узнать о наиболее важных свойствах хэш-функций, можно сначала изучить принцип ее работы.

## Изучение встроенной функции `hash()`

Прежде чем приступать к реализации хэш-функции с нуля, проанализируем функцию `hash()` в Python,
чтобы выявить ее свойства. Это поможет понять, с какими проблемами придется столкнуться при разработке собственной
хэш-функции.

> Примечание:
>
> Выбор хэш-функции может существенно повлиять на производительность хэш-таблицы. Поэтому при построении
> пользовательской хэш-таблицы далее в семинаре мы будем опираться на встроенную функцию `hash()`. Реализация
> хэш-функции в данном разделе является лишь упражнением.

Для начала попробуйте вызвать функцию `hash()` на нескольких встроенных в Python типов данных, таких как числа и
строки, чтобы посмотреть, как поведет себя функция:

```python
print(hash(3.14))
# >> 322818021289917443

print(hash(3.14159265358979323846264338327950288419716939937510))
# >> 326490430436040707

print(hash("Tink"))
# >> 6901473912843585146

print(hash("Lorem ipsum dolor sit amet, consectetur adipisicing elit,"
           "sed do eiusmod tempor incididunt ut labore et dolore magna"
           "aliqua. Ut enim ad minim veniam, quis nostrud exercitation"
           "ullamco laboris nisi ut aliquip ex ea commodo consequat."
           "Duis aute irure dolor in reprehenderit in voluptate velit"
           "esse cillum dolore eu fugiat nulla pariatur. Excepteur sint"
           "occaecat cupidatat non proident, sunt in culpa qui officia"
           "deserunt mollit anim id est laborum."))
# >> 656847885725097093
```

Уже сейчас, глядя на результат, можно сделать несколько наблюдений. Во-первых, встроенная хэш-функция может возвращать
разные значения для некоторых из приведенных выше входов. Если для числового ввода всегда получается одинаковое
хэш-значение, то для строкового, скорее всего, нет. Почему так происходит? Может показаться, что hash() -
недетерминированная функция, но это не так!

Если вызывать hash() с одним и тем же аргументом в рамках существующего сеанса интерпретатора, то результат будет один и
тот же:

```python
print(hash("Tink"))
# >> 6901473912843585146

print(hash("Tink"))
# >> 6901473912843585146

print(hash("Tink"))
# >> 6901473912843585146
```

Это связано с тем, что хэш-значения являются неизменяемыми и не меняются в течение всего времени жизни объекта. Однако
как только вы выйдете из Python и запустите его снова, то почти наверняка увидите разные хэш-значения при разных вызовах
Python. Проверить это можно, попробовав с помощью опции `-c` запустить в терминале однострочный скрипт:

```shell
$ python3 -c 'print(hash("Tink"))'
6182913096689556094

$ python3 -c 'print(hash("Tink"))'
1756821463709528809

$ python3 -c 'print(hash("Tink"))'
8971349716938911741
```

Это ожидаемое поведение, которое было реализовано в Python в качестве контрмеры против атаки типа "отказ в
обслуживании" ([DoS][dos]), использующей известную уязвимость хэш-функций в веб-серверах. Злоумышленники могли
использовать слабый хэш-алгоритм для преднамеренного создания так называемых хэш-коллизий, перегружая сервер и делая его
недоступным. Типичным мотивом атаки был выкуп, поскольку большинство жертв зарабатывали деньги на бесперебойной работе в
Интернете.

Сегодня Python по умолчанию включает рандомизацию хэша для некоторых входных данных, например, строк, чтобы сделать
хэш-значения менее предсказуемыми. Это делает функцию `hash()` немного более безопасной, а атаку - более сложной. Однако
рандомизацию можно отключить, задав фиксированное значение `seed`, например, с помощью переменной окружения
`PYTHONHASHSEED`:

```shell
$ PYTHONHASHSEED=1 python3 -c 'print(hash("Tink"))'
440669153173126140

$ PYTHONHASHSEED=1 python3 -c 'print(hash("Tink"))'
440669153173126140

$ PYTHONHASHSEED=1 python3 -c 'print(hash("Tink"))'
440669153173126140
```

Теперь каждый вызов Python дает одно и то же хэш-значение для известного входного сигнала. Это может помочь при
разделении или совместном использовании данных в кластере распределенных интерпретаторов Python. Только будьте осторожны
и понимайте риски, связанные с отключением рандомизации хэша. В целом, функция `hash()` в Python действительно является
детерминированной функцией, что является одним из наиболее фундаментальных свойств хэш-функции.

Кроме того, функция `hash()` представляется достаточно универсальной, поскольку принимает произвольные входные данные.
Другими словами, она принимает значения различных типов и размеров. Функция без проблем принимает строки и числа с
плавающей точкой, независимо от их длины и величины. Более того, можно вычислять хэш-значения и более экзотических
типов:

```python
print(hash(None))
# >> 5904497366826

print(hash(hash))


# >> 2938107101725

class Person:
    ...


print(hash(Person))
# >> 5904499092884

print(hash(Person()))
# >> 8738841746871

print(hash(Person()))
# >> 8738841586112
```

Здесь были вызваны хэш-функция для объекта `None` в Python, сама функция `hash()` и даже пользовательский класс `Person`
с несколькими его экземплярами. Однако не все объекты имеют соответствующее хэш-значение. Функция `hash()` вызовет
исключение, если попытаться вызвать ее для одного из этих немногих объектов:

```python
hash([1, 2, 3])
# >> Traceback (most recent call last):
# >>   File "<stdin>", line 1, in <module>
# >> TypeError: unhashable type: 'list'
```

Базовый тип входных данных определяет, можно ли вычислить хэш-значение. В Python экземпляры встроенных изменяемых
типов, таких как списки, множества и словари, не являются хэшируемыми. Вы уже получили представление о том, почему это
так, более подробную информацию вы получите в следующем разделе. Пока же можно считать, что большинство типов данных
вообще должны работать с хэш-функцией.

## Более глубокое изучение функции `hash()`

Еще одной интересной особенностью функции `hash()` является то, что она всегда выдает на выходе фиксированный размер,
независимо от того, насколько велик был входной сигнал. В Python хэш-значение представляет собой целое число с умеренной
величиной. Иногда оно может получиться отрицательным, поэтому учитывайте это, если планируете так или иначе использовать
хэш-значения:

```python
print(hash("Tink"))
# >> -972535290375435184
```

Естественным следствием фиксированного размера выходных данных является необратимая потеря большей части исходной
информации в процессе работы. Это вполне нормально, поскольку в конечном итоге вы хотите, чтобы полученное хэш-значение
представляло собой единый дайджест произвольно больших данных. Однако, поскольку хэш-функция проецирует потенциально
бесконечный набор значений на конечное пространство, это может привести к хэш-коллизии, когда на двух разных входах
получается одно и то же хэш-значение.

> Примечание:
>
> Если вы склонны к математике, то для более формального описания хэш-коллизий можно использовать
> [принцип Дирихле][Pigeonhole_principle]:
>
> > Дано m элементов и n контейнеров, если m > n, то существует хотя бы один контейнер, содержащий более одного
> > элемента.
>
> В данном контексте элементы - это потенциально бесконечное число значений, которые вы вводите в хэш-функцию, а
> контейнеры - это их хэш-значения, назначаемые из конечного пула.

Коллизии в хэш-таблицах - важнейшее понятие, к которому мы еще вернемся при реализации своей собственной хэш-таблицы.
Пока же можно считать их крайне нежелательными. Следует по возможности избегать хэш-коллизий, поскольку они могут
привести к очень неэффективному поиску и могут быть использованы хакерами. Поэтому хорошая хэш-функция должна
минимизировать вероятность хэш-коллизий как для безопасности, так и для эффективности.

На практике это часто означает, что хэш-функция должна присваивать значения, равномерно распределенные по доступному
пространству. Визуализировать распределение хэш-значений, выдаваемых функцией `hash()` в Python, можно, построив в
терминале текстовую гистограмму. Скопируйте следующий блок кода и сохраните его в файле с именем
[hash_distribution.py][hash_distribution]:

```python
# hash_distribution.py

from collections import Counter


def distribute(items, num_containers, hash_function=hash):
    return Counter([hash_function(item) % num_containers for item in items])


def plot(histogram):
    for key in sorted(histogram):
        count = histogram[key]
        padding = (max(histogram.values()) - count) * " "
        print(f"{key:3} {'■' * count}{padding} ({count})")
```

Для удобного представления гистограммы хэш-значений предоставленных элементов используется экземпляр `Counter`.
Хэш-значения распределяются по заданному количеству контейнеров путем их обертывания с помощью оператора `modulo`.
Теперь
можно взять, например, сто печатаемых ASCII-символов, вычислить их хэш-значения и показать их распределение:

```shell
from hash_distribution import plot, distribute
from string import printable

plot(distribute(printable, num_containers=2))
# >> 0 ■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■ (51)
# >> 1 ■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■   (49)

plot(distribute(printable, num_containers=5))
# >> 0 ■■■■■■■■■■■■■■■            (15)
# >> 1 ■■■■■■■■■■■■■■■■■■■■■■■■■■ (26)
# >> 2 ■■■■■■■■■■■■■■■■■■■■■■     (22)
# >> 3 ■■■■■■■■■■■■■■■■■■         (18)
# >> 4 ■■■■■■■■■■■■■■■■■■■        (19)
```

При наличии только двух контейнеров следует ожидать примерно пятидесятипроцентного распределения. Добавление большего
количества контейнеров должно привести к их более или менее равномерному заполнению. Как видите, встроенная функция
`hash()` неплохо, но не идеально справляется с равномерным распределением хэш-значений.

С этим связано то, что равномерное распределение хэш-значений обычно является псевдослучайным, что особенно важно для
криптографических хэш-функций. Это не позволяет потенциальным злоумышленникам с помощью статистического анализа
попытаться предсказать корреляцию между входными и выходными данными хэш-функции. Рассмотрим изменение одной буквы в
строке и проверим, как это повлияет на результирующее хэш-значение в Python:

```python
print(hash("Tink"))
# >> 1090207136701886571

print(hash("Loren"))
# >> 4415277245823523757
```

Теперь это совершенно другое хэш-значение, несмотря на то, что изменилась всего одна буква. Хэш-значения часто
подвержены лавинному эффекту, поскольку даже самое незначительное изменение входного сигнала усиливается. Тем не менее,
для реализации структуры данных хэш-таблицы эта особенность хэш-функции не является существенной.

В большинстве случаев функция `hash()` в Python проявляет еще одно несущественное свойство криптографических
хэш-функций,
которое вытекает из упомянутого ранее принципа Дирихле. Она ведет себя как односторонняя функция, поскольку найти ее
обратную величину в большинстве случаев практически невозможно. Однако есть заметные исключения:

```python
print(hash(42))
# >> 42
```

Хэш-значения небольших целых чисел равны самим себе, что является деталью реализации, которую CPython использует для
простоты и эффективности. Следует помнить, что фактические значения хэша не имеют значения, если вы можете вычислить их
детерминированным способом.

И последнее, но не менее важное: вычисление хэш-значения в Python происходит быстро, даже для очень больших входных
данных. На современном компьютере вызов функции `hash()` со строкой из 100 млн. символов в качестве аргумента
возвращается
мгновенно. Если бы это было не так быстро, то дополнительные накладные расходы на вычисление хэш-значения нивелировали
бы все преимущества хэширования.

## Определение свойств хэш-функции

На основании того, что вы узнали о функции `hash()` в Python, можно сделать выводы о желаемых свойствах хэш-функции в
целом. Приведем краткое описание этих свойств, сравнивая обычную хэш-функцию с ее криптографической разновидностью:

| Характеристика                         | Хэш-функция | Криптографическая хэш-функция |
|----------------------------------------|-------------|-------------------------------|
| Детерминированная                      | ✔️          | ✔️                            |
| Универсальный вход                     | ✔️          | ✔️                            |
| Выходной сигнал фиксированного размера | ✔️          | ✔️                            |
| Быстрое вычисление                     | ✔️          | ✔️                            |
| Равномерное распределение              | ✔️          | ✔️                            |
| Случайное распределение                | ✔️          |                               |
| Рандомизированное зерно                | ✔️          |                               |
| Односторонняя функция                  | ✔️          |                               |
| Лавинный эффект                        | ✔️          |                               |

Цели обоих типов хэш-функций совпадают, поэтому у них есть несколько общих черт. С другой стороны, криптографическая
хэш-функция предоставляет дополнительные гарантии безопасности.

Прежде чем создавать собственную хэш-функцию, рассмотрим другую функцию, встроенную в Python и являющуюся, на первый
взгляд, ее наиболее простой заменой.

## Сравнение идентификатора объекта с его хэшем

Пожалуй, одной из самых простых реализаций хэш-функции в Python является встроенная функция `id()`, которая позволяет
определить идентификационные данные объекта. В стандартном интерпретаторе Python идентификатор равен адресу памяти
объекта, выраженному в виде целого числа:

```python
print(id("Tink"))
# >> 139836146678832
```

Функция `id()` обладает большинством желаемых свойств хэш-функции. В частности, она очень быстрая и работает с любыми
входными данными. Она детерминированно возвращает целое число фиксированного размера. В то же время по адресу памяти
нельзя легко получить исходный объект. Сами адреса памяти неизменны в течение жизни объекта и несколько рандомизированы
между запусками интерпретатора.

Почему же тогда Python настаивает на использовании другой функции для хэширования?

Во-первых, смысл функции `id()` отличается от смысла функции `hash()`, поэтому в других дистрибутивах Python
идентификация может быть реализована альтернативными способами. Во-вторых, адреса памяти предсказуемы без равномерного
распределения, что и небезопасно, и крайне неэффективно для хэширования. Наконец, одинаковые объекты должны выдавать
один и тот же хэш-код, даже если они имеют разные идентификаторы.

> Примечание:
>
> Позже вы узнаете больше о контракте между равенством значений и соответствующими хэш-кодами.

Теперь можно, наконец, подумать о создании собственной хэш-функции.

## Создание собственной хэш-функции

Спроектировать хэш-функцию, удовлетворяющую всем требованиям, с нуля довольно сложно. Как уже говорилось, в следующем
разделе вы будете использовать встроенную функцию `hash()` для создания прототипа хэш-таблицы. Однако попытка построить
хэш-функцию с нуля - это отличный способ узнать, как она работает. К концу этого раздела у вас будет только
рудиментарная хэш-функция, которая далека от совершенства, но вы получите ценные знания.

В этом упражнении можно сначала ограничиться только одним типом данных и реализовать на его основе грубую хэш-функцию.
Например, можно рассматривать строки и суммировать порядковые значения отдельных символов в них:

```python
def hash_function(text: str) -> int:
    return sum(ord(character) for character in text)
```

Итерация по тексту выполняется с помощью генераторного выражения, затем каждый отдельный символ преобразуется в
соответствующую кодовую точку Unicode с помощью встроенной функции `ord()`, и, наконец, суммируются порядковые значения.
В результате для любого текста, заданного в качестве аргумента, будет получено одно число:

```python
print(hash_function("Backend"))
# >> 680

print(hash_function("Backeng"))
# >> 683

print(hash_function("Beckand"))
# >> 680
```

Сразу же можно заметить несколько проблем с этой функцией. Она не только специфична для строк, но и страдает от плохого
распределения хэш-кодов, которые имеют тенденцию образовывать кластеры при одинаковых входных значениях. Небольшое
изменение входных данных практически не влияет на наблюдаемый результат. Еще хуже то, что функция остается
нечувствительной к порядку символов в тексте, что означает, что анаграммы одного и того же слова, например `Backend` и
`Beckand`, приводят к коллизии хэш-кодов.

Чтобы решить первую проблему, попробуем преобразовать входные данные в строку с помощью вызова функции `str()`. Теперь
наша функция сможет работать с любым типом аргументов:

```python
def hash_function(key) -> int:
    return sum(ord(character) for character in str(key))


print(hash_function("Backend"))
# >> 680

print(hash_function(3.14))
# >> 198

print(hash_function(True))
# >> 416
```

Вы можете вызвать функцию `hash_function()` с аргументом любого типа данных, включая строку, число с плавающей точкой
или булево значение.

Обратите внимание, что данная реализация будет настолько хороша, насколько хорошо соответствующее строковое
представление. Некоторые объекты могут не иметь текстового представления, подходящего для приведённого выше кода. В
частности, хорошим примером являются экземпляры пользовательских классов, у которых не реализованы должным образом
специальные методы `__str__()` и `__repr__()`. Кроме того, вы не сможете различать различные типы данных:

```python
print(hash_function("3.14"))
# >> 198

print(hash_function(3.14))
# >> 198
```

В действительности вы хотите рассматривать строку `"3.14"` и число с плавающей точкой `3.14` как разные объекты с
разными хэш-кодами. Одним из способов смягчения этой проблемы является замена функции `str()` на функцию `repr()`,
которая оборачивает представление строк в дополнительные апострофы `'`:

```python
print(repr("3.14"))
# >> '3.14'

print(repr(3.14))
# >> 3.14
```

Это в некоторой степени улучшит нашу хэш-функцию:

```python
def hash_function(key) -> int:
    return sum(ord(character) for character in repr(key))


print(hash_function("3.14"))
# >> 276

print(hash_function(3.14))
# >> 198
```

Теперь строки можно отличить от чисел. Для решения проблемы с анаграммами, такими как `Backend` и `Bancked`, можно
модифицировать хэш-функцию, приняв во внимание значение символа и его положение в тексте:

```python
def hash_function(key) -> int:
    return sum(
        index * ord(character)
        for index, character in enumerate(repr(key), start=1)
    )
```

Здесь берется сумма произведений, полученных в результате перемножения порядковых значений символов и соответствующих им
индексов. Обратите внимание, что индексы перечисляются с единицы, а не с нуля. В противном случае первый символ всегда
будет отбрасываться, так как его значение будет умножаться на ноль.

Теперь наша хэш-функция достаточно универсальна и не вызывает такого количества коллизий, как раньше, но её выход может
вырасти произвольно большим, поскольку чем длиннее строка, тем больше хэш-код. Кроме того, при больших входных данных
она работает довольно медленно:

```python
print(hash_function("Tink"))
# >> 1731

print(hash_function("Tinkoff Backend Academy."))
# >> 30383

print(hash_function("Very long and slow work of hash_function!" * 1_000_000))
# >> 79704008134000117
```

Вы всегда можете решить проблему неограниченного роста, взяв модуль `%` вашего хэш-кода относительно известного
максимального размера, например, ста:

```python
print(hash_function("Tink") % 100)
# >> 31

print(hash_function("Tinkoff Backend Academy.") % 100)
# >> 83

print(hash_function("Very long and slow work of hash_function!" * 1_000_000) % 100)
# >> 17
```

Помните, что выбор меньшего количества хэш-кодов увеличивает вероятность коллизий хэш-кодов. Если вы не знаете заранее
количество входных значений, то лучше оставить это решение на потом, если есть такая возможность. Можно также наложить
ограничение на хэш-коды, приняв разумное максимальное значение, например [sys.maxsize][sys_maxsize], которое
представляет собой наибольшее значение целых чисел, поддерживаемое нативно в Python.

Если на время забыть о медленной скорости работы функции, то можно заметить еще одну особенность хэш-функции. Она
приводит к неоптимальному распределению хэш-кодов за счет кластеризации и неиспользования всех доступных слотов:

```python
from hash_distribution import plot, distribute
from string import printable

plot(distribute(printable, 6, hash_function))
# >> 0 ■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■   (31)
# >> 1 ■■■■                              (4)
# >> 2 ■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■   (31)
# >> 4 ■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■ (33)
# >> 5 ■                                 (1)
```

Распределение неравномерно. Более того, имеется шесть контейнеров, но один из них отсутствует на гистограмме. Эта
проблема связана с тем, что два апострофа, добавленные функцией `repr()`, приводят к тому, что практически все ключи в
этом примере дают чётное хэш-число. Избежать этого можно, удалив левый апостроф, если он существует:

```python
print(hash_function("a"), hash_function("b"), hash_function("c"))


# >> 350, 352, 354

def hash_function(key):
    return sum(
        index * ord(character)
        for index, character in enumerate(repr(key).lstrip("'"), start=1)
    )


print(hash_function("a"), hash_function("b"), hash_function("c"))
# >> 175, 176, 177

plot(distribute(printable, 6, hash_function))
# >> 0 ■■■■■■■■■■■■■■■■   (16)
# >> 1 ■■■■■■■■■■■■■■■■   (16)
# >> 2 ■■■■■■■■■■■■■■■    (15)
# >> 3 ■■■■■■■■■■■■■■■■■■ (18)
# >> 4 ■■■■■■■■■■■■■■■■■  (17)
# >> 5 ■■■■■■■■■■■■■■■■■■ (18)
```

Вызов `lstrip()` будет срабатывать на строку только в том случае, если она начинается с указанного префикса для
удаления.

Естественно, можно продолжать совершенствовать свою хэш-функцию и дальше. Если интересно, как реализована
функция `hash()` для строк и байтовых последовательностей в Python, то в настоящее время она использует алгоритм
[SipHash][SipHash], который может вернуться к модифицированной версии [FNV][FNV], если первая недоступна. Чтобы узнать,
какой хэш-алгоритм использует ваш интерпретатор Python, обратитесь к модулю sys:

```python
import sys

print(sys.hash_info.algorithm)
'siphash13'
```

На данный момент мы достаточно хорошо представляем, что такое хэш-функция, как она должна работать и с какими
трудностями мы можем столкнуться при её реализации. В последующих разделах будем использовать хэш-функцию для
построения хэш-таблицы. Выбор конкретного алгоритма хеширования будет влиять на производительность хеш-таблицы.
Основываясь на этих знаниях, вы сможете в дальнейшем осознанно использовать встроенную функцию `hash()`.

[Вернуться][main]

---

[main]: ../../README.md "содержание"

[hash_distribution]: ../../src/hash_distribution.py "hash_distribution"

[hashlib]: https://docs.python.org/3/library/hashlib.html "hashlib"

[dos]: https://en.wikipedia.org/wiki/Denial-of-service_attack "dos"

[sys_maxsize]: https://docs.python.org/3/library/sys.html#sys.maxsize "sys.maxsize"

[SipHash]: https://en.wikipedia.org/wiki/SipHash "SipHash"

[FNV]: https://en.wikipedia.org/wiki/Fowler–Noll–Vo_hash_function "FNV"

[Pigeonhole_principle]: https://ru.wikipedia.org/wiki/Принцип_Дирихле_(комбинаторика) "pigeonhole principle"
